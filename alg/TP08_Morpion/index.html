
<!DOCTYPE html>
<html>
<title>TP Morpion - JUnit</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="http://www.informatics-tech.com/highlighter/prettify.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins">
<script src='https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js' type='text/javascript'></script>
<script src="http://www.informatics-tech.com/highlighter/prettify.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
<style>
table tr th,td{
  border:1px solid black;
} 
body,h1,h2,h3,h4,h5 {font-family: "Poppins", sans-serif}
body {font-size:16px;}
.w3-half img{margin-bottom:-6px;margin-top:16px;opacity:0.8;cursor:pointer}
.w3-half img:hover{opacity:1}
pre.enLigne{display: inline;}
</style>
<body>

<!-- Sidebar/menu -->
<nav class="w3-sidebar w3-red w3-collapse w3-top w3-large w3-padding" style="z-index:3;width:300px;font-weight:bold;" id="mySidebar"><br>
  <a href="javascript:void(0)" onclick="w3_close()" class="w3-button w3-hide-large w3-display-topleft" style="width:100%;font-size:22px">Close Menu</a>
  <div class="w3-container">
    <h3 class="w3-padding-64"><b>IUT<br>Département-info</b></h3>
  </div>
  <div class="w3-bar-block">
    <a href="#showcase" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Introduction</a> 
    <a href="#services" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Principe des TU</a> 
    <a href="#exo1" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Morpion</a>
    <a href="#exo2" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Recherche d'une valeur dans un tableau</a> 
    <a href="#exo3" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Opérations entre matrices</a> 
    <a href="#exo4" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Carré magique</a> 
    
  </div>
</nav>

<!-- Top menu on small screens -->
<header class="w3-container w3-top w3-hide-large w3-red w3-xlarge w3-padding">
  <a href="javascript:void(0)" class="w3-button w3-red w3-margin-right" onclick="w3_open()">&#9776;</a>
  <span>Iut info BDX</span>
</header>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- !PAGE CONTENT! -->
<div class="w3-main" style="margin-left:340px;margin-right:40px">

  <!-- Header -->
  <div class="w3-container" style="margin-top:80px" id="showcase">
    <h1 class="w3-jumbo"><b>TP matrice - Tests unitaires</b></h1>
    <h1 class="w3-xxxlarge w3-text-red"><b>Mise en oeuvre avec le jeu du morpion</b></h1>
    <hr style="width:50px;border:5px solid red" class="w3-round">
  </div>
  
  <!-- Photo grid (modal) -->
  <div class="w3-row-padding">
    <div class="w3-half">
    <p>Lors cette séance vous allez découvrir l'importance et l'intérêt de faire des tests unitaires. Pour cela, vous allez devoir débugger un code Java permettant de jouer au Morpion.</p>
    </div>

    <div class="w3-half">
      <img src="img/morpion.jpeg">
    </div>
  </div>



  <!-- Modal for full size images on click-->
  <div id="modal01" class="w3-modal w3-black" style="padding-top:0" onclick="this.style.display='none'">
    <span class="w3-button w3-black w3-xxlarge w3-display-topright">&times;</span>
    <div class="w3-modal-content w3-animate-zoom w3-center w3-transparent w3-padding-64">
      <img id="img01" class="w3-image">
      <p id="caption"></p>
    </div>
  </div>

  <!-- Services -->
  <div class="w3-container" id="services" style="margin-top:75px">
    <h1 class="w3-xxxlarge w3-text-red"><b>Principe des tests unitaires</b></h1>
    <hr style="width:50px;border:5px solid red" class="w3-round">
    <p>
    
    </p>
    
    <h2>L'interface de tests</h2>
    <p>
    Nous allons commencer par prendre en main l'interface permettant de réaliser des tests.
    En premier lieu, récupérer <a href="code/morpion.zip">ce projet Morpion</a>.</p>
    <br>
    <p>Ce projet contient tout le code permettant de jouer au morpion. En toute logique il devrait fonctionner de la sorte :
    </p><ul>
      <li>Chaque joueur pose à tour de rôle son pion</li>
      <li>Le programme vérifie que le pion est posé sur une case libre et qui existe</li>
      <li>Le vainqueur est annoncé quand 3 pions sont alignés</li>
      <li>Annonce d'un match nul si pas de vainqueur</li>

    </ul>
    <p></p>

    <p>
    <video width="640" height="480" controls="">
    <source src="video/runMorpion.m4v" type="video/mp4">  
    Your browser does not support the video tag.
    </video>
    </p>

  

   







<h3>Question 1</h3>

<p>Compilez le code du morpion et testez-le. Vous observerez qu'il est buggé.</p>
<p>Votre premier réflexe est j'imagine d'aller chercher les bugs et de les corriger. C'est un bon reflexe, mais ça ne se fait pas n'importe comment ! Ca s'anticipe !</p>

<p>
 
 </p><h1>Les tests unitaires</h1>
 
 <h2>Présentation</h2>
<p> 
De manière générale, les tests servent à détecter des bugs, c'est-à-dire des différences entre ce qu'on attend de votre programme, et ce qu'il fait réellement. Par exemple l'appel somme(2,3) devrait renvoyer 5 mais renvoie 4.

Tout développeur produit des bugs. L'important c'est d'en faire peu, et surtout de les détecter tôt.

En effet, plus ils sont détectés tôt, plus ils sont faciles à trouver et  corriger, et accessoirement moins ils coûtent cher aux entreprises.

Plusieurs pratiques se développent dans ce sens, et plus généralement pour
améliorer la qualité logicielle :

</p><ul>
  <li>mieux définir ce qui doit être développé (qualité des spécifications,
meilleure communication avec le client via les méthodes agiles, etc).</li>
  <li>pair programming (coder à deux)</li>
  <li>revue de code (pour les curieux, exemple chez <a href="http://www.openbsd.org/security.html">OpenBSD</a> : paragraphe Audit Process)</li>
  <li>validation (prouver formellement des programmes, abordé en Licence Pro DAGPI)</li>
  <li>tests</li>

</ul> 


<img src="img/tests.jpg"><p></p>
<p>
Il existe plusieurs types de tests : unitaires, fonctionnels, d'intégration, 
etc.
Pour l'instant on ne s'intéresse qu'aux tests unitaires, c'est-à-dire des tests qui portent sur des petites portions de code, typiquement une fonction.
Un test unitaire consiste alors à lancer la fonction sur plusieurs valeurs,
et comparer chaque résultat avec la valeur souhaitée.

Le test possède une bonne couverture s'il teste beaucoup de valeurs, et surtout différents cas de figure, les cas critiques, etc.

Par exemple pour la fonction somme, on peut tester:
</p><ul>
  <li>somme(2,3) == 5 la somme de deux entiers positifs</li>
  <li>somme(2,0) == 2 la somme d'un positif avec zéro</li>
  <li>somme(0,3) == 3 la somme de zéro avec un entier positif</li>
  <li>somme(0,0) == 0 la somme de zéro avec lui-même</li>
  <li>somme(1,-1) == 0 la somme d'un positif et d'un négatif</li>
  <li>somme(-1,-1) == -2 la somme de deux négatifs</li>
  <li>somme(-1,0) == -1 la somme d'un négatif avec zéro</li>
</ul>




Une fois ces tests rédigés (on verra comment ci-dessous), ils constituent une partie de votre programme, et peuvent être relancés à tout moment.
Par exemple les serveurs d'intégration continue permettent de relancer
automatiquement tous les tests unitaires à chaque modification de 
votre programme (ceux qui suivront le parcours P2 au S4 le verront en 
Qualité logicielle).
<p></p>

<p>
Quand faut-il écrire les tests unitaires?
A vous de voir, les pratiques divergent selon les entreprises.
Un premier réflexe est de les écrire après que la fonction soit codée.
On peut aussi les écrire avant, en laissant au début la fonction vide
(exemple : somme() renvoie toujours zéro). 
Les tests seront faux au début, puis vrais petit à petit quand vous coderez.
L'intérêt est de réfléchir à tous les cas limites avant de coder,
et de ne pas écrire les tests sous l'influence de son code.</p>


<div class="w3-container" id="exo1" style="margin-top:75px">
    <h1 class="w3-xxxlarge w3-text-red"><b>Morpion</b></h1>
    <hr style="width:50px;border:5px solid red" class="w3-round">
  

<h2>JUnit</h2>

<p>Un module très utilisé en Java pour faire des tests unitaires est   <a href="http://junit.org/junit4/">JUnit</a>. 

<br>

<img src="img/junit.png">

<p>
  Nous allons créer une classe <tt>MorpionTest</tt> contenant
  les tests unitaires des fonctions de la classe <tt>Morpion</tt>.
</p>

<p>
  Dans chaque projet NetBeans (dans l'arborescence de gauche) apparaît :
  <ul>
    <li>Source Packages : emplacement du <em>code source</em></li>
    <li>Test Packages : emplacement des <em>tests unitaires</em>.</li>
  </ul>

  Ainsi, dans <em>Test Packages</em>,
  faire un clic droit sur le dossier <tt>morpion</tt>
  (à créer si ce n'est pas déjà fait), choisir New / Java class...
  et créer ainsi la classe <tt>MorpionTest.java</tt>.
  
  Y créer la fonction <tt>testInitialiserGrille()</tt> avec le code ci-dessous : 
</p><pre class="prettyprint">
@Test
public void testInitialiserGrille() {
    int taille = 3;
    int[][] grille = {{-1, -1, -1}, { -1, -1, -1}, { -1, -1, -1}};
    Morpion.initialiserGrille(taille, grille);
    for (int lig = 0; lig < grille.length; lig++) {
        for (int col = 0; col < grille[lig].length; col++) {
            assertEquals(0, grille[lig][col]);
        }
    }
}
</pre>

Ce test contient du code qui successivement :

<ul>
  <li>Déclare une grille où chaque case est initialisée à -1</li>
  <li>Effectue l'appel à la fonction initialiserGrille()</li>
  <li>Teste que chaque case de la grille vaut bien 0.
	La fonction <pre class="prettyprint enLigne"> assertEquals(0, grille[lig][col])</pre>
	s'assure que la case (lig,col) contient la valeur 0 (0 signifie que la case est vide).
	Si ce n'est pas le cas alors un message d'erreur sera affiché.</li>
</ul>

	<p>Concernant JUnit :
	  <ul>
		<li>
		  l'annotation <b><tt>@Test</tt></b> permet à JUnit d'identifier
		  les fonctions qui sont des tests unitaires.
		  Remarque : si une annotation <tt>@Test</tt> ne compile pas,
		  importez la bibliothèque JUnit comme suggéré par NetBeans.
		</li>
		<li>
		  la méthode <b><tt>assertEquals(valeurAttendue, valeurCalculee)</tt></b>
		  s'assure que <tt>valeurCalculee</tt> vaut bien le résultat attendu,
		  c'est-à-dire <tt>valeurAttendue</tt>.
		</li>
		<li>
		  la méthode <b><tt>assertTrue(monTest)</tt></b>
		  s'assure que le booléen <tt>monTest</tt> est vrai.
		</li>
		<li>
		  symétriquement, la méthode <b><tt>assertFalse(monTest)</tt></b>
		  s'assure que le booléen <tt>monTest</tt> est faux.
		</li>
	  </ul>
	</p>

	<p>
	  Il y a plusieurs façons de lancer les tests unitaires,
	  selon ce que l'on veut faire :
	  <table>
		<tr>
		  <td>lancer tous les tests d'une classe</td>
		  <td>clic droit sur le fichier (à gauche), puis "Tester le fichier"</td>
		</tr>
		<tr>
		  <td>idem, mais en mode debug</td>
		  <td>clic droit sur le fichier (à gauche), puis "Déboguer en testant fichier"</td>
		</tr>
		<tr>
		  <td>lancer un test unitaire (une méthode)</td>
		  <td>clic droit sur le nom de la méthode, puis "Run Focused Test Method"</td>
		</tr>
		<tr>
		  <td>idem, en mode debug</td>
		  <td>clic droit sur le nom de la méthode, puis "Debug Focused Test Method"</td>
		</tr>
	  </table>
	</p>


<p>Lorsque vous exécutez ces tests, une fenêtre s'ouvre et vous indique les tests réussis et ceux qui ont échoué. Par exemple dans notre cas voici ce que vous indique JUnit selon qu'un assert ait détecté une erreur ou pas.<br/>

  <img src="img/testsOK.png">
  <img src="img/testsNOK.png">
</p>


<h3>Question 2</h3>

<p>Corrigez le code de la fonction initialiserGrille() pour qu'elle passe les tests.</p>


<h3>Question 3</h3>

<p>Recopiez le code du test de la fonction isColonneComplete() et exécutez le test unitaire. Vous remarquerez qu'il ne passe pas.</p>

<pre class="prettyprint"> 
    @Test
    public void testIsColonneComplete(){
        int taille = 3;
        int[][] grille1 = {{0, 0, 0}, {0, 0, 0},{0, 0, 0}};
        int[][] grille2 = {{2, 1, 1}, {1, 2, 2},{1, 2, 1}};
        int[][] grille3 = {{0, 1, 0}, {0, 1, 2},{2, 1, 0}};
        int[][] grille4 = {{2, 1, 1}, {2, 0, 0},{2, 1, 0}};
        int[][] grille5 = {{1, 0, 2}, {1, 0, 2},{0, 1, 0}};
        
        for (int i = 0; i < 3; i++) {
            assertFalse(Morpion.isColonneComplete(i, taille, grille1));
        }      
        
        for (int i = 0; i < 3; i++) {
            assertFalse(Morpion.isColonneComplete(i, taille, grille2));
        }        
        
        assertFalse(Morpion.isColonneComplete(0, taille, grille3));
        assertTrue( Morpion.isColonneComplete(1, taille, grille3));
        assertFalse(Morpion.isColonneComplete(2, taille, grille3));
        
        assertTrue( Morpion.isColonneComplete(0, taille, grille4));
        assertFalse(Morpion.isColonneComplete(1, taille, grille4));
        assertFalse(Morpion.isColonneComplete(2, taille, grille4));
        
        assertFalse(Morpion.isColonneComplete(0, taille, grille5));
        assertFalse(Morpion.isColonneComplete(1, taille, grille5));
        assertTrue( Morpion.isColonneComplete(2, taille, grille5));
    }
}</pre>


<p>Dans le cas testé, la fonction isColonneComplete() est bonne. C'est le test unitaire qui présente une erreur. Et oui, un test unitaire reste un code comme un autre. Il peut contenir des erreurs. Identifiez l'erreur commise dans ce test unitaire et corrigez-le.</p>



<h3>Question 4 </h3>

<p>Les fonctions isDiagonaleI() et changerJoueur() contiennent chacune un (et un seul) bug. Pour chacune d'entre elle :

</p><ul>
  <li>Ecrivez les tests unitaires</li>
  <li>Identifiez l'erreur</li>
  <li>Corrigez l'erreur.</li>
</ul>
<p></p>


<h3>Question 5 </h3>
  <p> Une fois les tests passés, réalisez plusieurs parties et vérifiez que tout est conforme à la vidéo du début de l'exercice. </p>



<h3>Question 6 </h3>
	<p>Lorsque l'on programme, il est important de commenter son code. Nous l'avons vu, Java propose un format appelé <a href="https://fr.wikipedia.org/wiki/Javadoc">javadoc</a> qui permet de générer une documentation (quasi) automatiquement.</p>
	<p>Avant cela effectuez le réglage suivant dans NetBeans : menu
	Outil / Options / Éditeur / Indices / Javadoc / Créer Javadoc (et Error in
	Javadoc) / passer de <tt>protected</tt> à <tt>private</tt>.
	  </p>
	<p>Puis cliquez droit sur votre fichier Morpion.java, faites Outils
	/ Analyse Javadoc. NetBeans vous propose de sélectionner les
	fonctions à commenter puis va, en fonction des paramètres de la
	fonction, ajouter en commentaire des mots clefs qui seront
	utilisés plus tard par le générateur de documentation.

<pre class="prettyprint">
/**
 * Initialise une grille, c'est-à-dire met 0 dans chacune de ses cases.
 * @param taille taille de la grille carrée, supérieure à 0
 * @param grille tableau 2D d'entiers. Chaque case vaut :
 * -1 si non initialisée,
 *  0 si vide,
 *  1 si le joueur 1 a posé son pion dessus,
 *  2 si le joueur 2 a posé son pion dessus.
 */
public static void initialiserGrille(int taille, int[][] grille) {
    int i, j;
    for (i = 0; i < taille; i++) {
        for (j = 0; j < taille-1; j++) {
            grille[i][j] = 0;
        }
    }
}
</pre>
     
	<p>Par défaut NetBeans ne génère la documentation que pour les attributs et méthodes <em>public</em>. 
	  Pour générer la documentation pour tous les attributs et méthodes :
	  <ul>
		<li>faîtes un clic droit sur votre projet Morpion-ETU et allez dans Propriétés / Documentation,</li>
		<li>cochez "Inclure les membres privés et les membres Package Private" et validez,</li>
		<li>en cliquant droit à nouveau sur le projet puis
		  sur "Génération de la Javadoc" un site web contenant toute la documentation
		  sera généré automatiquement.</li>
	  </ul>
	</p>

<p><img src="img/javadoc.png"></p>


<p>Commentez TOUTES les fonctions du Morpion et générez la Javadoc.</p>

</div>

    <div class="w3-container" id="exo2" style="margin-top:75px">
      <h1 class="w3-xxxlarge w3-text-red"><b>Recherche d'une valeur dans un tableau</b></h1>
      <hr style="width:50px;border:5px solid red" class="w3-round">


      <p>Nous allons nous intéresser à la recherche d’une valeur dans un tableau d’entiers. Nous prendrons les conventions
        suivantes :
        <ul>
          <li>si la valeur recherchée est dans le tableau, la fonction de recherche doit retourner l’indice d’une case contenant cette valeur</li>
          <li>sinon, la fonction de recherche retourne -1.</li>
        </ul>

        Deux méthodes sont à implémenter dans cet exercice. La première permet de chercher une valeur dans un tableau non trié, la seconde dans un tableau trié.
		Le projet à importer est <a href="./code/Recherche.zip">Recherche.zip</a>.
      </p>

      <h2>Question 1</h2>

      Préparez les tests unitaires de <pre class="prettyprint enLigne">rechercheLineaire()</pre> et <pre class="prettyprint enLigne">rechercheDichotomique()</pre>  dans les méthodes <pre class="prettyprint enLigne">testRechercheLineaire()</pre> et <pre class="prettyprint enLigne">testRechercheDichotomique()</pre>

      <h2>Question 2</h2>
      Implémentez les méthodes <pre class="prettyprint enLigne">rechercheLineaire()</pre> et <pre class="prettyprint enLigne">rechercheDichotomique()</pre> en respectant les signatures données. 

    </div>




<div class="w3-container" id="exo3" style="margin-top:75px">
    <h1 class="w3-xxxlarge w3-text-red"><b>Opérations entre matrices</b></h1>
    <hr style="width:50px;border:5px solid red" class="w3-round">

<h3>Addition et soustraction de matrices</h3>


<p>Pour additionner ou soustraire deux matrices rien de plus simple. Il suffit que les deux matrices aient la même taille et de soustraire/additionner terme à terme les éléments.
</p>
<p>
Par exemple : 

</p><table style="display:inline-block">
   <tbody><tr>
       <td>5</td>
       <td>0</td>
       <td>4</td>
   </tr>
   <tr>
       <td>2</td>
       <td>3</td>
       <td>4</td>
   </tr>
  
</tbody></table>
+
<table style="display:inline-block">
   <tbody><tr>
       <td>1</td>
       <td>0</td>
       <td>1</td>
   </tr>
   <tr>
       <td>2</td>
       <td>0</td>
       <td>1</td>
   </tr>
  
</tbody></table>
=
<table style="display:inline-block">
   <tbody><tr>
       <td>6</td>
       <td>0</td>
       <td>5</td>
   </tr>
   <tr>
       <td>4</td>
       <td>3</td>
       <td>5</td>
   </tr>
  
</tbody></table>

et


<table style="display:inline-block">
   <tbody><tr>
       <td>5</td>
       <td>0</td>
       <td>4</td>
   </tr>
   <tr>
       <td>2</td>
       <td>3</td>
       <td>4</td>
   </tr>
  
</tbody></table>
-
<table style="display:inline-block">
   <tbody><tr>
       <td>1</td>
       <td>0</td>
       <td>1</td>
   </tr>
   <tr>
       <td>2</td>
       <td>0</td>
       <td>1</td>
   </tr>
  
</tbody></table>
=
<table style="display:inline-block">
   <tbody><tr>
       <td>4</td>
       <td>0</td>
       <td>3</td>
   </tr>
   <tr>
       <td>0</td>
       <td>3</td>
       <td>3</td>
   </tr>
  
</tbody></table>
<p></p>
<h3>Question 1</h3>
Récupérez le <a href="code/matriceMath.zip">code java du projet "matriceMath"</a>. Ce projet contient deux fonctions contenant des "bugs".


  
<pre class="prettyprint">
    /**
     * Addition de deux matrices de même taille.
     * 
     * @param mat1 la première matrice
     * @param mat2 la seconde matrice
     * @return la matrice résultat de l'addition des matrices en paramètre
     */
    static int[][] add(int[][] mat1, int[][] mat2) {
        int[][] matRes = new int[mat1.length][mat1[0].length];
        for (int i = 0; i < mat1.length; i++) {
            for (int j = 0; j < mat1.length; j++) {
                matRes[i][j] = mat1[i][j] + mat2[i][j];
            }
        }
        return matRes;
    }

    /**
     * Soustraction de deux matrices de même taille.
     * 
     * @param mat1 la première matrice
     * @param mat2 la seconde matrice
     * @return la matrice résultat de la soustraction des matrices en paramètre
     */
    static int[][] sub(int[][] mat1, int[][] mat2) {
        int[][] matRes = new int[mat1.length][mat1[0].length];
        for (int i = 0; i < mat1.length; i++) {
            for (int j = 0; j < mat1.length; j++) {
                matRes[i][j] = mat1[i][j] - mat1[i][j];
            }
        }
        return matRes;
    }
</pre>

<p>
Dans cet exercice on supposera que l'utilisateur est intelligent et qu'il rentrera toujours deux matrices de même taille.


Créez les deux tests unitaires nécessaires. Identifiez la ou les erreurs et corrigez-les.


Nous vous invitons à utiliser la méthode </p><pre class="prettyprint enLigne">assertArrayEquals(,)</pre> qui permet de comparer deux tableaux sans avoir à faire soi-même la double boucle.

Par exemple 
<pre class="prettyprint enLigne ">assertArrayEquals(new int[]{1,2,3}, new int[]{1,21,3});</pre>
 génèrera un affichage dans lequel sera indiqué l'indice du tableau dont les cases diffèrent.
<p></p>

<p><img src="img/array.png"></p>

</div>









<div class="w3-container" id="exo4" style="margin-top:75px">
    <h1 class="w3-xxxlarge w3-text-red"><b>Carré magique (facultatif)</b></h1>
    <hr style="width:50px;border:5px solid red" class="w3-round">
<p>Lors de la création d'un gros projet de développement, il se peut que les tests (unitaires ou autres) soient confiés à une équipe différente de celle qui a codé les fonctions. Cet exercice reproduit ce cas de figure. Une équipe a codé 8 versions d'une fonction permettant de créer un carré magique de dimension 3X3.</p>


<p>Pour rappel, lisez la <a href="https://fr.wikipedia.org/wiki/Carr%C3%A9_magique_(math%C3%A9matiques)">définition Wikipédia d'un carré magique</a>.</p>

<h3>Question 1</h3>

<p>Récupérez <a href="code/carreMagique.zip">le projet</a>.

Il permet de demander à un service web (a priori buggé) de générer, case par case, les chiffres d'un carré magique 3X3.</p>
<p>
    <video width="640" height="480" controls="">
    <source src="video/magique.m4v" type="video/mp4">  
    Your browser does not support the video tag.
    </video>
</p>

<p>
Regardez le main() :
</p><pre class="prettyprint ">
public static void main(String[] args) {
    int[][] carre = {{-1, -1, -1}, {-1, -1, -1}, {-1, -1, -1}};
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            carre[i][j] = requeteCarre.getVal(1, 5, i, j);
            System.out.print(carre[i][j] + " ");
        }
        System.out.println(" ");
    }
}
</pre>


<img src="img/attention.png">Il y a un passage important. C'est celui de l'appel à la fonction que vous n'avez pas codée et que vous devez tester.

<pre class="prettyprint ">requeteCarre.getVal(int version, int valeurInitiale, int ligne, int colonne);</pre>

L'équipe ayant codé les 8 versions de cette fonction vous donne les indications suivantes : 

<ul>
  <li>version est un entier entre 1 et 8 et correspond à la version de la fonction que vous souhaitez tester</li>
  <li>valeurInitiale est un entier strictement POSITIF et correspond à la valeur placée en ligne 1 colonne 2 du carré magique et permettant de générer n'importe quel carré magique.</li>
  <li>les variables ligne et colonne servent à préciser la case du carré 3X3 que l'on souhaite obtenir.</li>
  <li>la fonction retourne la valeur située en [ligne][colonne]. Elle retourne -1 si version n'est pas entre 1 et 8, -1 si valeurInitiale&lt;=0 , -1 si les variables lignes ou colonnes ne sont pas comprises entre 0 et 2.</li>
  
</ul>



Avec une valeur initiale de 4 (obligatoirement placée en [1,2] par le serveur), le serveur créera le carré magique suivant :
<table>
   <tbody><tr>
       <td>5</td>
       <td>0</td>
       <td>4</td>
   </tr>
   <tr>
       <td>2</td>
       <td>3</td>
       <td style="color:red;">4</td>
   </tr>
   <tr>
       <td>2</td>
       <td>6</td>
       <td>1</td>
   </tr>
</tbody></table>



Avec une valeur initiale de 5 (obligatoirement placée en [1,2] par le serveur), la fonction sans bug (parmi les 8) sur le serveur créera le carré magique suivant :

<table>
   <tbody><tr>
       <td>6</td>
       <td>1</td>
       <td>5</td>
   </tr>
   <tr>
       <td>3</td>
       <td>4</td>
       <td style="color:red;">5</td>
   </tr>
   <tr>
       <td>3</td>
       <td>7</td>
       <td>2</td>
   </tr>
</tbody></table>

Si vous voulez récupérer les 9 valeurs de la version 1 de la fonction, il vous faudra 9 appels :
<pre class="prettyprint">
  int[][] carre = {{-1, -1, -1}, {-1, -1, -1}, {-1, -1, -1}};
  carre[0][0] = requeteCarre.getVal(1, 5, 0, 0); // doit retourner 6
  carre[0][1] = requeteCarre.getVal(1, 5, 0, 1); // doit retourner 1
  carre[0][2] = requeteCarre.getVal(1, 5, 0, 2); // doit retourner 5
  carre[1][0] = requeteCarre.getVal(1, 5, 1, 0); // doit retourner 3
  ...
  carre[2][2] = requeteCarre.getVal(1, 5, 2, 2); // doit retourner 2
</pre>

C'est exactement ce que fait le code que je vous ai donné (avec la double boucle).

<h3>Question 2</h3>

<p>À vous de coder la fonction 
</p><pre class="prettyprint">static boolean isMagique(int[][] magique)</pre>
Cette fonction permet de vérifier qu'une matrice 3X3 est un carré magique (si vous êtes malin, inspirez-vous du code du morpion).<p></p>

<h3>Question 3</h3>

Réalisez les tests unitaires de cette fonction.

<h3>Question 4</h3>

<p>Utilisez cette fonction pour réaliser les tests unitaires et découvrir la SEULE fonction valide parmi les 8 qui ont été codées.</p>

</div>
<!-- 
<pre class="prettyprint">
void nextStep()
</pre>
permettant de faire une itération du cycle de vie de la matrice.
</p>

<p>Si votre code est correct, la grille suivante devrait apparaitre</p>
<p><img src="img/life1.png"></p>
 -->

</div>
<!-- 
<pre class="prettyprint">
void nextStep()
</pre>
permettant de faire une itération du cycle de vie de la matrice.
</p>

<p>Si votre code est correct, la grille suivante devrait apparaitre</p>
<p><img src="img/life1.png"></p>
 -->

</div>
<div class="w3-light-grey w3-container w3-padding-32" style="margin-top:75px;padding-right:58px"><p class="w3-right">Powered by <a href="https://www.w3schools.com/w3css/default.asp" title="W3.CSS" target="_blank" class="w3-hover-opacity">w3.css</a></p></div>

<script>
// Script to open and close sidebar
function w3_open() {
    document.getElementById("mySidebar").style.display = "block";
    document.getElementById("myOverlay").style.display = "block";
}
 
function w3_close() {
    document.getElementById("mySidebar").style.display = "none";
    document.getElementById("myOverlay").style.display = "none";
}

// Modal Image Gallery
function onClick(element) {
  document.getElementById("img01").src = element.src;
  document.getElementById("modal01").style.display = "block";
  var captionText = document.getElementById("caption");
  captionText.innerHTML =  element.alt;
}
</script>

</body>
</html>
